//
// nekRS User Defined File
//
#include "udf.hpp"
#include "nekAscent.hpp"

#ifdef __okl__

#endif

static int ioStepAscent = 0;

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{}

void UDF_Setup()
{
  auto mesh = nrs->mesh;

  const auto uzMin = platform->linAlg->min(mesh->Nlocal, mesh->o_x, platform->comm.mpiComm);
  const auto uzMax = platform->linAlg->max(mesh->Nlocal, mesh->o_z, platform->comm.mpiComm);
  const auto zlen = uzMax - uzMin;

  // IC
  if (platform->options.getArgs("RESTART FILE NAME").empty()) {
    { // velocity, copy from turbPipePeriodic
      auto [xm, ym, zm] = mesh->xyzHost(); // x[n], y[n], z[n]
      std::vector<dfloat> U(mesh->dim * nrs->fieldOffset, 0.0);
      std::vector<dfloat> P(nrs->fieldOffset, 0.0);
      for (int e = 0; e < mesh->Nelements; e++) {
        for (int iz = 0; iz<mesh->Nq; iz++) {
        for (int iy = 0; iy<mesh->Nq; iy++) {
        for (int ix = 0; ix<mesh->Nq; ix++) {
          const auto n = e*mesh->Np + iz*mesh->Nq*mesh->Nq + iy*mesh->Nq + ix;
          const auto ieg = nek::localElementIdToGlobal(e); // 0-base
          const dfloat x = xm[n];
          const dfloat y = ym[n];
          const dfloat z = zm[n];
          const dfloat xr = x/0.5;
          const dfloat yr = y/0.5;
          const dfloat rr = sqrt(xr*xr+yr*yr);
          const dfloat th = std::atan2(y,x);
          const dfloat zo = 2.0*M_PI*z/zlen;
          dfloat uz = 6.0 * (1.0-pow(rr,6.0)) / 5.0;

          const dfloat amp_z = 0.35;
          const dfloat freq_z = 4.0;
          const dfloat freq_t = 9.0;
          const dfloat amp_tht = 5.0;
          const dfloat amp_clip = 0.2;
          const dfloat blt = 0.07;
          const dfloat phase_z = amp_z*(2*M_PI)*sin(freq_z*zo);
          const dfloat arg_tht = freq_t*th + phase_z;
          dfloat amp_sin = 5*sin(arg_tht);
          if (amp_sin >  amp_clip) amp_sin =  amp_clip;
          if (amp_sin < -amp_clip) amp_sin = -amp_clip;
          if (rr > (1.0-blt)) uz = uz + amp_sin;

          const dfloat big = 1.e3*(ieg+1) + 1.e2*(ix+1) + 1.e1*(iy+1) + 1.e0*(iz+1);
          const dfloat rand = sin(big);

          U[n + 0 * nrs->fieldOffset] = 0.05*rand*rand;
          U[n + 1 * nrs->fieldOffset] = 0.10*rand*rand;
          U[n + 2 * nrs->fieldOffset] = uz +  0.01*rand;
          P[n] = 0.0;
        }}}
      }
      nrs->o_U.copyFrom(U.data(), U.size());
      nrs->o_P.copyFrom(P.data(), P.size());
    }
  }

#ifdef NEKRS_ASCENT_ENABLED 
  {
    platform->par->extract("casedata", "ioStepAscent", ioStepAscent);

    deviceMemory<dfloat> o_ux(nrs->o_U.slice(0 * nrs->fieldOffset));
    deviceMemory<dfloat> o_uy(nrs->o_U.slice(1 * nrs->fieldOffset));
    deviceMemory<dfloat> o_uz(nrs->o_U.slice(2 * nrs->fieldOffset));
    std::vector<deviceMemory<dfloat>> o_U{o_ux, o_uy, o_uz};
    nekAscent::addVariable("velocity", mesh, o_U);

    const int Nviz = 13;            // polynomial order used in visualization
    const auto uniform = true;      // uniform grid or Gauss-Lobatto points
//    const auto stageThroughHost = false; // works on frontier
    const auto stageThroughHost = true; // works on my laptop and frontier
    const auto async = true;        // asyncronization mode, it's faster on Frontier
    nekAscent::setup(mesh, "ascent.yaml", Nviz, uniform, stageThroughHost, async);
  }
#endif
}
 
void UDF_ExecuteStep(double time, int tstep)
{
  if (nrs->checkpointStep) {
    nrs->copyToNek(time, tstep);
    nek::userchk();
  }

#ifdef NEKRS_ASCENT_ENABLED
  if ((ioStepAscent > 0) && (tstep % ioStepAscent == 0) && (tstep > 0)) {
    nekAscent::run(time, tstep);
  }
  if (nrs->lastStep) nekAscent::finalize();
#endif
}
